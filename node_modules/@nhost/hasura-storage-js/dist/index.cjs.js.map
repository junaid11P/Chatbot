{"version":3,"file":"index.cjs.js","sources":["../src/utils/upload.ts","../src/utils/appendImageTransformationParameters/appendImageTransformationParameters.ts","../src/hasura-storage-api.ts","../src/hasura-storage-client.ts","../src/machines/file-upload.ts","../src/machines/multiple-files-upload.ts","../src/promises/file-upload.ts","../src/promises/multiple-files-upload.ts"],"sourcesContent":["import fetchPonyfill from 'fetch-ponyfill'\nimport LegacyFormData from 'form-data'\nimport { StorageErrorPayload, StorageUploadResponse } from './types'\n\nlet fetch = globalThis.fetch\n\n/** Convert any string into ISO-8859-1 */\nexport const toIso88591 = (fileName: string) => {\n  try {\n    btoa(fileName)\n    return fileName\n  } catch {\n    return encodeURIComponent(fileName)\n  }\n}\n\nexport const fetchUpload = async (\n  backendUrl: string,\n  data: FormData | LegacyFormData,\n  {\n    accessToken,\n    name,\n    fileId,\n    bucketId,\n    adminSecret,\n    onUploadProgress,\n    headers: initialHeaders = {}\n  }: {\n    accessToken?: string\n    name?: string\n    fileId?: string\n    bucketId?: string\n    adminSecret?: string\n    onUploadProgress?: (event: { total: number; loaded: number }) => void\n    headers?: Record<string, string>\n  } = {}\n): Promise<StorageUploadResponse> => {\n  const headers: HeadersInit = {\n    ...initialHeaders\n  }\n  if (bucketId) {\n    data.append('bucket-id', bucketId)\n  }\n  if (adminSecret) {\n    headers['x-hasura-admin-secret'] = adminSecret\n  }\n  if (accessToken) {\n    headers['Authorization'] = `Bearer ${accessToken}`\n  }\n\n  const url = `${backendUrl}/files`\n  if (typeof XMLHttpRequest === 'undefined') {\n    // * Non-browser environment: XMLHttpRequest is not available\n    try {\n      if (data instanceof LegacyFormData) {\n        fetch = fetchPonyfill().fetch\n      }\n\n      const response = await fetch(url, {\n        method: 'POST',\n        headers,\n        body: data as any // * https://github.com/form-data/form-data/issues/513\n      })\n\n      const responseData = await response.json()\n\n      if (!response.ok) {\n        const error: StorageErrorPayload = {\n          status: response.status,\n          message: responseData?.error?.message || response.statusText,\n          // * errors from hasura-storage are not codified\n          error: response.statusText\n        }\n        return { error, fileMetadata: null }\n      }\n      const fileMetadata = responseData\n      return { fileMetadata, error: null }\n    } catch (e) {\n      const error: StorageErrorPayload = {\n        status: 0,\n        message: (e as Error).message,\n        error: (e as Error).message\n      }\n      return { error, fileMetadata: null }\n    }\n  }\n\n  // * Browser environment: XMLHttpRequest is available\n  return new Promise((resolve) => {\n    let xhr = new XMLHttpRequest()\n    xhr.responseType = 'json'\n\n    xhr.onload = () => {\n      if (xhr.status < 200 || xhr.status >= 300) {\n        const error: StorageErrorPayload = {\n          error: xhr.response?.error?.message ?? xhr.response?.error ?? xhr.response,\n          message: xhr.response?.error?.message ?? xhr.response,\n          status: xhr.status\n        }\n        return resolve({\n          fileMetadata: null,\n          error\n        })\n      }\n      return resolve({ fileMetadata: xhr.response, error: null })\n    }\n\n    xhr.onerror = () => {\n      // only triggers if the request couldn't be made at all e.g. network error\n      const error: StorageErrorPayload = {\n        error: xhr.statusText,\n        message: xhr.statusText,\n        status: xhr.status\n      }\n      return resolve({\n        fileMetadata: null,\n        error\n      })\n    }\n\n    if (onUploadProgress) {\n      xhr.upload.addEventListener('progress', onUploadProgress, false)\n    }\n\n    xhr.open('POST', url, true)\n\n    Object.entries(headers).forEach(([key, value]) => {\n      xhr.setRequestHeader(key, value)\n    })\n\n    xhr.send(data as any) // * https://github.com/form-data/form-data/issues/513\n  })\n}\n","import { StorageImageTransformationParams } from '../types'\n\n/**\n * Appends image transformation parameters to the URL. If the URL already\n * contains query parameters, the transformation parameters are appended to\n * the existing query parameters.\n *\n * @internal\n * @param url - The URL to append the transformation parameters to.\n * @param params - The image transformation parameters.\n * @returns The URL with the transformation parameters appended.\n */\nexport default function appendImageTransformationParameters(\n  url: string,\n  params?: StorageImageTransformationParams\n): string {\n  if (!params || Object.keys(params).length === 0) {\n    return url\n  }\n\n  const urlObject = new URL(url)\n\n  // create an object with the transformation parameters by using the first\n  // character of the parameter name as the key\n  const imageTransformationParams = Object.entries(params).reduce(\n    (accumulator, [key, value]) => ({ ...accumulator, [key.charAt(0)]: value }),\n    {} as Record<string, any>\n  )\n\n  // set the query parameters in the URL object\n  Object.entries(imageTransformationParams).forEach(([key, value]) => {\n    if (!value) {\n      return\n    }\n\n    urlObject.searchParams.set(key, value)\n  })\n\n  return urlObject.toString()\n}\n","import fetchPonyfill from 'fetch-ponyfill'\n\nimport LegacyFormData from 'form-data'\nimport {\n  ApiDeleteParams,\n  ApiDeleteResponse,\n  ApiGetPresignedUrlParams,\n  ApiGetPresignedUrlResponse,\n  StorageDownloadFileParams,\n  StorageDownloadFileResponse,\n  StorageUploadFileParams,\n  StorageUploadFileResponse,\n  StorageUploadFormDataParams,\n  StorageUploadFormDataResponse\n} from './utils/types'\nimport { fetchUpload } from './utils/upload'\nimport { appendImageTransformationParameters } from './utils'\n\nlet fetch: any\n\nif (typeof fetch === 'undefined') {\n  fetch = fetchPonyfill().fetch\n}\n\n/**\n * @internal\n * This is an internal class.\n */\nexport class HasuraStorageApi {\n  private url: string\n  private accessToken?: string\n  private adminSecret?: string\n  private headers: Record<string, string> = {}\n\n  constructor({ url }: { url: string }) {\n    this.url = url\n  }\n\n  async uploadFormData({\n    formData,\n    bucketId,\n    headers: extraHeaders\n  }: StorageUploadFormDataParams): Promise<StorageUploadFormDataResponse> {\n    const { error, fileMetadata } = await fetchUpload(this.url, formData, {\n      bucketId,\n      headers: {\n        ...this.headers, // global nhost storage client headers to be sent with all `uploadFormData` calls\n        ...extraHeaders // extra headers to be sent with a specific call\n      },\n      accessToken: this.accessToken,\n      adminSecret: this.adminSecret\n    })\n\n    if (error) {\n      return { fileMetadata: null, error }\n    }\n\n    if (fileMetadata && !('processedFiles' in fileMetadata)) {\n      return {\n        fileMetadata: {\n          processedFiles: [fileMetadata]\n        },\n        error: null\n      }\n    }\n\n    return { fileMetadata, error: null }\n  }\n\n  async uploadFile({\n    file,\n    bucketId,\n    id,\n    name,\n    headers: extraHeaders\n  }: StorageUploadFileParams): Promise<StorageUploadFileResponse> {\n    const formData = typeof window === 'undefined' ? new LegacyFormData() : new FormData()\n\n    formData.append('file[]', file)\n    formData.append('metadata[]', JSON.stringify({ id, name }))\n\n    const { error, fileMetadata } = await fetchUpload(this.url, formData, {\n      accessToken: this.accessToken,\n      adminSecret: this.adminSecret,\n      bucketId,\n      fileId: id,\n      name,\n      headers: {\n        ...this.headers, // global nhost storage client headers to be sent with all `uploadFile` calls\n        ...extraHeaders // extra headers to be sent with a specific call\n      }\n    })\n\n    if (error) {\n      return { fileMetadata: null, error }\n    }\n\n    if (fileMetadata && 'processedFiles' in fileMetadata) {\n      return {\n        fileMetadata: fileMetadata.processedFiles[0],\n        error: null\n      }\n    }\n\n    return { fileMetadata, error: null }\n  }\n\n  async downloadFile(params: StorageDownloadFileParams): Promise<StorageDownloadFileResponse> {\n    try {\n      const { fileId, headers: extraHeaders, ...imageTransformationParams } = params\n\n      const urlWithParams = appendImageTransformationParameters(\n        `${this.url}/files/${fileId}`,\n        imageTransformationParams\n      )\n\n      const response = await fetch(urlWithParams, {\n        method: 'GET',\n        headers: {\n          ...this.generateAuthHeaders(),\n          ...this.headers, // global nhost storage client headers to be sent with all `downloadFile` calls\n          ...extraHeaders // extra headers to be sent with a specific call\n        }\n      })\n\n      if (!response.ok) {\n        throw new Error(await response.text())\n      }\n\n      const file = await response.blob()\n\n      return { file, error: null }\n    } catch (error) {\n      return { file: null, error: error as Error }\n    }\n  }\n\n  async getPresignedUrl(params: ApiGetPresignedUrlParams): Promise<ApiGetPresignedUrlResponse> {\n    try {\n      const { fileId, headers: extraHeaders } = params\n\n      const response = await fetch(`${this.url}/files/${fileId}/presignedurl`, {\n        method: 'GET',\n        headers: {\n          ...this.generateAuthHeaders(),\n          ...this.headers, // global nhost storage client headers to be sent with all `getPresignedUrl` calls\n          ...extraHeaders // extra headers to be sent with a specific call\n        }\n      })\n      if (!response.ok) {\n        throw new Error(await response.text())\n      }\n      const presignedUrl = await response.json()\n      return { presignedUrl, error: null }\n    } catch (error) {\n      return { presignedUrl: null, error: error as Error }\n    }\n  }\n\n  async delete(params: ApiDeleteParams): Promise<ApiDeleteResponse> {\n    try {\n      const { fileId, headers: extraHeaders } = params\n      const response = await fetch(`${this.url}/files/${fileId}`, {\n        method: 'DELETE',\n        headers: {\n          ...this.generateAuthHeaders(),\n          ...this.headers, // global nhost storage client headers to be sent with all `delete` calls\n          ...extraHeaders // extra headers to be sent with a specific call\n        }\n      })\n      if (!response.ok) {\n        throw new Error(await response.text())\n      }\n      return { error: null }\n    } catch (error) {\n      return { error: error as Error }\n    }\n  }\n\n  /**\n   * Set the access token to use for authentication.\n   *\n   * @param accessToken Access token\n   * @returns Hasura Storage API instance\n   */\n  setAccessToken(accessToken?: string): HasuraStorageApi {\n    this.accessToken = accessToken\n\n    return this\n  }\n\n  /**\n   * Set the admin secret to use for authentication.\n   *\n   * @param adminSecret Hasura admin secret\n   * @returns Hasura Storage API instance\n   */\n  setAdminSecret(adminSecret?: string): HasuraStorageApi {\n    this.adminSecret = adminSecret\n\n    return this\n  }\n\n  /**\n   * Get global headers sent with all requests.\n   *\n   * @returns Record<string, string>\n   */\n  getHeaders(): Record<string, string> {\n    return this.headers\n  }\n\n  /**\n   * Set global headers to be sent with all requests.\n   *\n   * @param headers a key value pair headers object\n   * @returns Hasura Storage API instance\n   */\n  setHeaders(headers?: Record<string, string>): HasuraStorageApi {\n    if (!headers) {\n      return this\n    }\n\n    this.headers = {\n      ...this.headers,\n      ...headers\n    }\n\n    return this\n  }\n\n  /**\n   * Remove global headers sent with all requests, except for the role header to preserve\n   * the role set by 'setRole' method.\n   *\n   * @returns {HasuraStorageApi} - Hasura Storage API instance.\n   */\n  unsetHeaders(): HasuraStorageApi {\n    const userRole = this.headers['x-hasura-role']\n\n    // preserve the user role header to avoid invalidating preceding 'setRole' call.\n    this.headers = userRole ? { 'x-hasura-role': userRole } : {}\n\n    return this\n  }\n\n  private generateAuthHeaders(): HeadersInit | undefined {\n    if (!this.adminSecret && !this.accessToken) {\n      return undefined\n    }\n\n    if (this.adminSecret) {\n      return {\n        'x-hasura-admin-secret': this.adminSecret\n      }\n    }\n\n    return {\n      Authorization: `Bearer ${this.accessToken}`\n    }\n  }\n}\n","import { HasuraStorageApi } from './hasura-storage-api'\nimport {\n  appendImageTransformationParameters,\n  StorageDeleteParams,\n  StorageDeleteResponse,\n  StorageGetPresignedUrlParams,\n  StorageGetPresignedUrlResponse,\n  StorageGetUrlParams,\n  StorageUploadFileParams,\n  StorageUploadFileResponse,\n  StorageUploadFormDataParams,\n  StorageUploadFormDataResponse,\n  StorageUploadParams,\n  StorageUploadResponse,\n  StorageDownloadFileParams,\n  StorageDownloadFileResponse\n} from './utils'\n\nexport interface NhostStorageConstructorParams {\n  /**\n   * Storage endpoint.\n   */\n  url: string\n  /**\n   * Admin secret. When set, it is sent as an `x-hasura-admin-secret` header for all requests.\n   */\n  adminSecret?: string\n}\n/**\n * @alias Storage\n */\nexport class HasuraStorageClient {\n  readonly url: string\n  private api: HasuraStorageApi\n\n  constructor({ url, adminSecret }: NhostStorageConstructorParams) {\n    this.url = url\n    this.api = new HasuraStorageApi({ url })\n    this.setAdminSecret(adminSecret)\n  }\n\n  /**\n   * Use `nhost.storage.upload` to upload a file. \n   * \n   * It's possible to use [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) or [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) to upload a file. The `File` instance is only available in the browser while `FormData` with [`form-data`](https://www.npmjs.com/package/form-data) works both in the browser and in NodeJS (server).\n   * \n   * If no `bucketId` is specified the bucket `default` is used.\n   *\n   * @example\n   * \n   * Upload a file from a browser using `File`.\n   * \n   * ```ts\n   * await nhost.storage.upload({ file })\n   * ```\n   * \n   * Upload a file from a browser using `File` to a specific Bucket.\n   * \n    @example\n   * ```ts\n   * await nhost.storage.upload({ file, bucketId: '<Bucket-ID>' })\n   * ```\n   * \n   * Upload a file from a server using `FormData` with [`form-data`](https://www.npmjs.com/package/form-data).\n   *\n   * @example\n   * ```ts\n   * const fd = new FormData() \n   * fd.append('file', fs.createReadStream('./tests/assets/sample.pdf'))\n   * \n   * await storage.upload({\n   *   formData: fd\n   * })\n   * ```\n   * \n   * @docs https://docs.nhost.io/reference/javascript/storage/upload\n   */\n\n  async upload(params: StorageUploadFileParams): Promise<StorageUploadFileResponse>\n  async upload(params: StorageUploadFormDataParams): Promise<StorageUploadFormDataResponse>\n  async upload(params: StorageUploadParams): Promise<StorageUploadResponse> {\n    if ('file' in params) {\n      return this.api.uploadFile(params)\n    }\n\n    return this.api.uploadFormData(params)\n  }\n\n  /**\n   * Use `nhost.storage.getPublicUrl` to get the public URL of a file. The public URL can be used for un-authenticated users to access files. To access public files the `public` role must have permissions to select the file in the `storage.files` table.\n   *\n   * @example\n   * ```ts\n   * const publicUrl = nhost.storage.getPublicUrl({ fileId: '<File-ID>' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/get-public-url\n   */\n  getPublicUrl(params: StorageGetUrlParams): string {\n    const { fileId, ...imageTransformationParams } = params\n    return appendImageTransformationParameters(\n      `${this.url}/files/${fileId}`,\n      imageTransformationParams\n    )\n  }\n\n  /**\n   * Use `nhost.storage.getPresignedUrl` to get a presigned URL of a file. To get a presigned URL the user must have permission to select the file in the `storage.files` table.\n   *\n   * @example\n   * ```ts\n   * const { presignedUrl, error} = await nhost.storage.getPresignedUrl({ fileId: '<File-ID>' })\n   *\n   * if (error) {\n   *   throw error;\n   * }\n   *\n   * console.log('url: ', presignedUrl.url)\n   * console.log('expiration: ', presignedUrl.expiration)\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/get-presigned-url\n   */\n  async getPresignedUrl(\n    params: StorageGetPresignedUrlParams\n  ): Promise<StorageGetPresignedUrlResponse> {\n    const { fileId, headers, ...imageTransformationParams } = params\n    const { presignedUrl, error } = await this.api.getPresignedUrl(params)\n\n    if (error) {\n      return { presignedUrl: null, error }\n    }\n\n    if (!presignedUrl) {\n      return { presignedUrl: null, error: new Error('Invalid file id') }\n    }\n\n    const urlWithTransformationParams = appendImageTransformationParameters(\n      presignedUrl.url,\n      imageTransformationParams\n    )\n\n    return {\n      presignedUrl: {\n        ...presignedUrl,\n        url: urlWithTransformationParams\n      },\n      error: null\n    }\n  }\n\n  /**\n   * Use `nhost.storage.download` to download a file. To download a file the user must have permission to select the file in the `storage.files` table.\n   *\n   * @example\n   * ```ts\n   * const { file, error} = await nhost.storage.download({ fileId: '<File-ID>' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/download\n   */\n  async download(params: StorageDownloadFileParams): Promise<StorageDownloadFileResponse> {\n    const { file, error } = await this.api.downloadFile(params)\n\n    if (error) {\n      return { file: null, error }\n    }\n\n    if (!file) {\n      return { file: null, error: new Error('File does not exist') }\n    }\n\n    return {\n      file,\n      error: null\n    }\n  }\n\n  /**\n   * Use `nhost.storage.delete` to delete a file. To delete a file the user must have permissions to delete the file in the `storage.files` table. Deleting the file using `nhost.storage.delete()` will delete both the file and its metadata.\n   *\n   * @example\n   * ```ts\n   * const { error } = await nhost.storage.delete({ fileId: 'uuid' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/delete\n   */\n  async delete(params: StorageDeleteParams): Promise<StorageDeleteResponse> {\n    const { error } = await this.api.delete(params)\n    if (error) {\n      return { error }\n    }\n\n    return { error: null }\n  }\n\n  /**\n   * Use `nhost.storage.setAccessToken` to a set an access token to be used in subsequent storage requests. Note that if you're signin in users with `nhost.auth.signIn()` the access token will be set automatically.\n   *\n   * @example\n   * ```ts\n   * nhost.storage.setAccessToken('some-access-token')\n   * ```\n   *\n   * @param accessToken Access token\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/set-access-token\n   */\n  setAccessToken(accessToken?: string): HasuraStorageClient {\n    this.api.setAccessToken(accessToken)\n\n    return this\n  }\n\n  /**\n   * Use `nhost.storage.adminSecret` to set the admin secret to be used for subsequent storage requests. This is useful if you want to run storage in \"admin mode\".\n   *\n   * @example\n   * ```ts\n   * nhost.storage.setAdminSecret('some-admin-secret')\n   * ```\n   *\n   * @param adminSecret Hasura admin secret\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/set-admin-secret\n   */\n  setAdminSecret(adminSecret?: string): HasuraStorageClient {\n    this.api.setAdminSecret(adminSecret)\n\n    return this\n  }\n\n  /**\n   * Use `nhost.storage.getHeaders` to get global headers sent with all storage requests.\n   *\n   * @example\n   * ```ts\n   * nhost.storage.getHeaders()\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/get-headers\n   */\n  getHeaders(): Record<string, string> {\n    return this.api.getHeaders()\n  }\n\n  /**\n   * Use `nhost.storage.setHeaders` to set global headers to be sent for all subsequent storage requests.\n   *\n   * @example\n   * ```ts\n   * nhost.storage.setHeaders({\n   *  'x-hasura-role': 'admin'\n   * })\n   * ```\n   *\n   * @param headers key value headers object\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/set-headers\n   */\n  setHeaders(headers?: Record<string, string>): HasuraStorageClient {\n    this.api.setHeaders(headers)\n\n    return this\n  }\n\n  /**\n   * Use `nhost.storage.unsetHeaders` to remove the global headers sent for all subsequent storage requests.\n   *\n   * @example\n   * ```ts\n   * nhost.storage.unsetHeaders()\n   * ```\n   *\n   * @param headers key value headers object\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/unset-headers\n   */\n  unsetHeaders(): HasuraStorageClient {\n    this.api.unsetHeaders()\n    return this\n  }\n}\n","import { assign, createMachine } from 'xstate'\nimport { FileUploadConfig, StorageErrorPayload } from '../utils'\nimport { fetchUpload } from '../utils/upload'\n\nimport FallbackFormData from 'form-data'\n\nlet FormData: any\n\nif (typeof FormData === 'undefined') {\n  FormData = FallbackFormData\n}\n\nexport type FileUploadContext = {\n  progress: number | null\n  loaded: number\n  error: StorageErrorPayload | null\n  id?: string\n  bucketId?: string\n  file?: File\n}\n\nexport type FileUploadEventPayload = {}\nexport type FileUploadEvents =\n  | { type: 'ADD'; file: File; id?: string; bucketId?: string; name?: string }\n  | ({\n      type: 'UPLOAD'\n      file?: File\n      id?: string\n      name?: string\n      bucketId?: string\n    } & FileUploadConfig)\n  | { type: 'UPLOAD_PROGRESS'; progress: number; loaded: number; additions: number }\n  | { type: 'UPLOAD_DONE'; id: string; bucketId: string }\n  | { type: 'UPLOAD_ERROR'; error: StorageErrorPayload }\n  | { type: 'CANCEL' }\n  | { type: 'DESTROY' }\n\nexport const INITIAL_FILE_CONTEXT: FileUploadContext = {\n  progress: null,\n  loaded: 0,\n  error: null,\n  bucketId: undefined,\n  file: undefined,\n  id: undefined\n}\n\nexport type FileUploadMachine = ReturnType<typeof createFileUploadMachine>\nexport const createFileUploadMachine = () =>\n  createMachine(\n    {\n      predictableActionArguments: true,\n      schema: {\n        context: {} as FileUploadContext,\n        events: {} as FileUploadEvents\n      },\n      tsTypes: {} as import('./file-upload.typegen').Typegen0,\n      context: { ...INITIAL_FILE_CONTEXT },\n      initial: 'idle',\n      on: {\n        DESTROY: { actions: 'sendDestroy', target: 'stopped' }\n      },\n      states: {\n        idle: {\n          on: {\n            ADD: { actions: 'addFile' },\n            UPLOAD: { cond: 'hasFile', target: 'uploading' }\n          }\n        },\n        uploading: {\n          entry: 'resetProgress',\n          on: {\n            UPLOAD_PROGRESS: { actions: ['incrementProgress', 'sendProgress'] },\n            UPLOAD_DONE: 'uploaded',\n            UPLOAD_ERROR: 'error',\n            CANCEL: 'idle'\n          },\n          invoke: { src: 'uploadFile' }\n        },\n        uploaded: {\n          entry: ['setFileMetadata', 'sendDone'],\n          on: {\n            ADD: { actions: 'addFile', target: 'idle' },\n            UPLOAD: { actions: 'resetContext', target: 'uploading' }\n          }\n        },\n        error: {\n          entry: ['setError', 'sendError'],\n          on: {\n            ADD: { actions: 'addFile', target: 'idle' },\n            UPLOAD: { actions: 'resetContext', target: 'uploading' }\n          }\n        },\n        stopped: { type: 'final' }\n      }\n    },\n    {\n      guards: {\n        hasFile: (context, event) => !!context.file || !!event.file\n      },\n\n      actions: {\n        incrementProgress: assign({\n          loaded: (_, { loaded }) => loaded,\n          progress: (_, { progress }) => progress\n        }),\n        setFileMetadata: assign({\n          id: (_, { id }) => id,\n          bucketId: (_, { bucketId }) => bucketId,\n          progress: (_) => 100\n        }),\n        setError: assign({ error: (_, { error }) => error }),\n        sendProgress: () => {},\n        sendError: () => {},\n        sendDestroy: () => {},\n        sendDone: () => {},\n        resetProgress: assign({ progress: (_) => null, loaded: (_) => 0 }),\n        resetContext: assign((_) => INITIAL_FILE_CONTEXT),\n        addFile: assign({\n          file: (_, { file }) => file,\n          bucketId: (_, { bucketId }) => bucketId,\n          id: (_, { id }) => id\n        })\n      },\n      services: {\n        uploadFile: (context, event) => (callback) => {\n          const file = (event.file || context.file)!\n          const data = new FormData()\n          data.append('file[]', file)\n\n          let currentLoaded = 0\n\n          fetchUpload(event.url, data, {\n            fileId: event.id || context.id,\n            bucketId: event.bucketId || context.bucketId,\n            accessToken: event.accessToken,\n            adminSecret: event.adminSecret,\n            name: event.name || file.name,\n            onUploadProgress: (event) => {\n              const loaded = event.total ? Math.round((event.loaded * file.size!) / event.total) : 0\n              const additions = loaded - currentLoaded\n              currentLoaded = loaded\n              callback({\n                type: 'UPLOAD_PROGRESS',\n                progress: event.total ? Math.round((loaded * 100) / event.total) : 0,\n                loaded,\n                additions\n              })\n            }\n          }).then(({ fileMetadata, error }) => {\n            if (error) {\n              callback({ type: 'UPLOAD_ERROR', error })\n            }\n            if (fileMetadata && !('processedFiles' in fileMetadata)) {\n              const { id, bucketId } = fileMetadata\n              callback({ type: 'UPLOAD_DONE', id, bucketId })\n            }\n\n            if (fileMetadata && 'processedFiles' in fileMetadata) {\n              // TODO: Add support for multiple files\n              const { id, bucketId } = fileMetadata.processedFiles[0]\n              callback({ type: 'UPLOAD_DONE', id, bucketId })\n            }\n          })\n\n          return () => {}\n        }\n      }\n    }\n  )\n","import { actions, ActorRefFrom, assign, createMachine, send, spawn } from 'xstate'\n\nimport { FileUploadConfig } from '../utils'\n\nimport { createFileUploadMachine, FileUploadMachine, INITIAL_FILE_CONTEXT } from './file-upload'\n\nconst { pure, sendParent } = actions\n\nexport type FileItemRef = ActorRefFrom<FileUploadMachine>\n\nexport type AnyFileList = File | File[] | FileList\n\nexport type MultipleFilesUploadContext = {\n  progress: number | null\n  files: FileItemRef[]\n  loaded: number\n  total: number\n}\n\nexport type MultipleFilesUploadEvents =\n  | { type: 'ADD'; files: AnyFileList; bucketId?: string }\n  | ({\n      type: 'UPLOAD'\n      files?: AnyFileList\n      bucketId?: string\n    } & FileUploadConfig)\n  | { type: 'UPLOAD_PROGRESS'; additions: number }\n  | { type: 'UPLOAD_DONE' }\n  | { type: 'UPLOAD_ERROR' }\n  | { type: 'CANCEL' }\n  | { type: 'REMOVE' }\n  | { type: 'CLEAR' }\n\nexport type MultipleFilesUploadMachine = ReturnType<typeof createMultipleFilesUploadMachine>\n\nexport const createMultipleFilesUploadMachine = () => {\n  return createMachine(\n    {\n      id: 'files-list',\n      schema: {\n        context: {} as MultipleFilesUploadContext,\n        events: {} as MultipleFilesUploadEvents\n      },\n      tsTypes: {} as import('./multiple-files-upload.typegen').Typegen0,\n      predictableActionArguments: true,\n      context: {\n        progress: null,\n        files: [],\n        loaded: 0,\n        total: 0\n      },\n      initial: 'idle',\n      on: {\n        UPLOAD: { cond: 'hasFileToDownload', actions: 'addItem', target: 'uploading' },\n        ADD: { actions: 'addItem' },\n        REMOVE: { actions: 'removeItem' }\n      },\n      states: {\n        idle: {\n          entry: ['resetProgress', 'resetLoaded', 'resetTotal'],\n          on: {\n            CLEAR: { actions: 'clearList', target: 'idle' }\n          }\n        },\n        uploading: {\n          entry: ['upload', 'startProgress', 'resetLoaded', 'resetTotal'],\n          on: {\n            UPLOAD_PROGRESS: { actions: ['incrementProgress'] },\n            UPLOAD_DONE: [\n              { cond: 'isAllUploaded', target: 'uploaded' },\n              { cond: 'isAllUploadedOrError', target: 'error' }\n            ],\n            UPLOAD_ERROR: [\n              { cond: 'isAllUploaded', target: 'uploaded' },\n              { cond: 'isAllUploadedOrError', target: 'error' }\n            ],\n            CANCEL: { actions: 'cancel', target: 'idle' }\n          }\n        },\n        uploaded: {\n          entry: 'setUploaded',\n          on: {\n            CLEAR: { actions: 'clearList', target: 'idle' }\n          }\n        },\n        error: {\n          on: {\n            CLEAR: { actions: 'clearList', target: 'idle' }\n          }\n        }\n      }\n    },\n    {\n      guards: {\n        hasFileToDownload: (context, event) =>\n          context.files.some((ref) => ref.getSnapshot()!.matches('idle')) || !!event.files,\n        isAllUploaded: (context) =>\n          context.files.every((item) => item.getSnapshot()?.matches('uploaded')),\n        isAllUploadedOrError: (context) =>\n          context.files.every((item) => {\n            const snap = item.getSnapshot()\n            return snap?.matches('error') || snap?.matches('uploaded')\n          })\n      },\n\n      actions: {\n        incrementProgress: assign((context, event) => {\n          const loaded: number = context.loaded + event.additions\n          const progress = Math.round((loaded * 100) / context.total)\n          return { ...context, loaded, progress }\n        }),\n        setUploaded: assign({\n          progress: (_) => 100,\n          loaded: ({ files }) =>\n            files\n              .map((ref) => ref.getSnapshot()!)\n              .filter((snap) => snap.matches('uploaded'))\n              .reduce((agg, curr) => agg + curr.context.file?.size!, 0)\n        }),\n        resetTotal: assign({\n          total: ({ files }) =>\n            files\n              .map((ref) => ref.getSnapshot()!)\n              .filter((snap) => !snap.matches('uploaded'))\n              .reduce((agg, curr) => agg + curr.context.file?.size!, 0)\n        }),\n        resetLoaded: assign({ loaded: (_) => 0 }),\n        startProgress: assign({ progress: (_) => 0 }),\n        resetProgress: assign({ progress: (_) => null }),\n        addItem: assign((context, { files, bucketId }) => {\n          const additions = files\n            ? Array.isArray(files)\n              ? files // File[]\n              : 'item' in files // FileList\n              ? Array.from(files)\n              : [files] // File\n            : [] // No file\n          const total = context.total + additions.reduce((agg, curr) => agg + curr.size, 0)\n          const progress = Math.round((context.loaded * 100) / total)\n          return {\n            files: [\n              ...context.files,\n              ...additions.map((file) =>\n                spawn(\n                  createFileUploadMachine()\n                    .withConfig({\n                      actions: {\n                        sendProgress: sendParent((_, { additions }) => ({\n                          type: 'UPLOAD_PROGRESS',\n                          additions\n                        })),\n                        sendDone: sendParent('UPLOAD_DONE'),\n                        sendError: sendParent('UPLOAD_ERROR'),\n                        sendDestroy: sendParent('REMOVE')\n                      }\n                    })\n                    .withContext({ ...INITIAL_FILE_CONTEXT, file, bucketId }),\n                  { sync: true }\n                )\n              )\n            ],\n            total,\n            loaded: context.loaded,\n            progress\n          }\n        }),\n        removeItem: assign({\n          files: (context) =>\n            context.files.filter((ref) => {\n              const stopped = ref.getSnapshot()?.matches('stopped')\n              if (stopped) {\n                ref.stop?.()\n              }\n              return !stopped\n            })\n        }),\n        clearList: pure((context) =>\n          context.files.map((ref) => send({ type: 'DESTROY' }, { to: ref.id }))\n        ),\n        upload: pure((context, event) => context.files.map((ref) => send(event, { to: ref.id }))),\n        cancel: pure((context) =>\n          context.files.map((ref) => send({ type: 'CANCEL' }, { to: ref.id }))\n        )\n      }\n    }\n  )\n}\n","import { InterpreterFrom } from 'xstate'\n\nimport { FileItemRef, FileUploadMachine } from '../machines'\nimport { FileUploadConfig, StorageActionErrorState, StorageUploadFileParams } from '../utils'\n\nexport interface UploadProgressState {\n  /**\n   * Returns `true` when the file is being uploaded.\n   */\n  isUploading: boolean\n  /**\n   * Returns the progress of the upload, from 0 to 100. Returns null if the upload has not started yet.\n   */\n  progress: number | null\n}\n\nexport interface UploadFileHandlerResult extends StorageActionErrorState {\n  /**\n   * Returns `true` when the file has been successfully uploaded.\n   */\n  isUploaded: boolean\n  /**\n   * Returns the id of the file.\n   */\n  id?: string\n  /**\n   * Returns the bucket id.\n   */\n  bucketId?: string\n  /**\n   * Returns the name of the file.\n   */\n  name?: string\n}\n\nexport interface FileUploadState extends UploadFileHandlerResult, UploadProgressState {}\n\nexport const uploadFilePromise = async (\n  params: FileUploadConfig & Partial<StorageUploadFileParams>,\n  interpreter: FileItemRef | InterpreterFrom<FileUploadMachine>\n): Promise<UploadFileHandlerResult> =>\n  new Promise<UploadFileHandlerResult>((resolve) => {\n    interpreter.send({\n      type: 'UPLOAD',\n      ...params\n    })\n    interpreter.subscribe((s) => {\n      if (s.matches('error')) {\n        resolve({\n          error: s.context.error,\n          isError: true,\n          isUploaded: false\n        })\n      } else if (s.matches('uploaded')) {\n        resolve({\n          error: null,\n          isError: false,\n          isUploaded: true,\n          id: s.context.id,\n          bucketId: s.context.id,\n          name: s.context.file?.name\n        })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { AnyFileList, FileItemRef, MultipleFilesUploadMachine } from '../machines'\nimport { FileUploadConfig } from '../utils'\n\nexport interface MultipleUploadProgressState {\n  /**\n   * Returns `true` when the files are being uploaded.\n   */\n  isUploading: boolean\n  /**\n   * Returns the overall progress of the upload, from 0 to 100. Returns null if the upload has not started yet.\n   */\n  progress: number | null\n}\n\nexport interface MultipleFilesHandlerResult {\n  /**\n   * The list of file uploads. The properties can be accessed through `item.getSnapshot()` of with the `useFileUploadItem` hook.\n   */\n  files: FileItemRef[]\n  /**\n   * Returns `true` when all upload request are processed, but at least one of them has failed.\n   */\n  isError: boolean\n  /**\n   * Returns the list of file uploads that have failed\n   */\n  errors: FileItemRef[]\n}\n\nexport interface MultipleFilesUploadState\n  extends MultipleFilesHandlerResult,\n    MultipleUploadProgressState {\n  /**\n   * Returns `true` when all the files have been successfully uploaded.\n   */\n  isUploaded: boolean\n}\n\nexport type UploadMultipleFilesActionParams = {\n  files?: AnyFileList\n  bucketId?: string\n}\n\nexport const uploadMultipleFilesPromise = async (\n  params: FileUploadConfig & UploadMultipleFilesActionParams,\n  service: InterpreterFrom<MultipleFilesUploadMachine>\n): Promise<MultipleFilesHandlerResult> =>\n  new Promise((resolve) => {\n    service.send({\n      type: 'UPLOAD',\n      ...params,\n      files: params.files\n    })\n    service.onTransition((s) => {\n      if (s.matches('error')) {\n        resolve({\n          errors: s.context.files.filter((ref) => ref.getSnapshot()?.context.error),\n          isError: true,\n          files: []\n        })\n      } else if (s.matches('uploaded')) {\n        resolve({ errors: [], isError: false, files: s.context.files })\n      }\n    })\n  })\n"],"names":["fetch","fetchUpload","backendUrl","data","accessToken","name","fileId","bucketId","adminSecret","onUploadProgress","initialHeaders","headers","url","LegacyFormData","fetchPonyfill","response","responseData","_a","e","resolve","xhr","error","_e","_d","_b","_c","_h","_g","_f","key","value","appendImageTransformationParameters","params","urlObject","imageTransformationParams","accumulator","HasuraStorageApi","__publicField","formData","extraHeaders","fileMetadata","file","id","urlWithParams","userRole","HasuraStorageClient","presignedUrl","urlWithTransformationParams","FormData","FallbackFormData","INITIAL_FILE_CONTEXT","createFileUploadMachine","createMachine","context","event","assign","_","loaded","progress","callback","currentLoaded","additions","pure","sendParent","actions","createMultipleFilesUploadMachine","ref","item","snap","files","agg","curr","total","spawn","stopped","send","uploadFilePromise","interpreter","uploadMultipleFilesPromise","service"],"mappings":"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"}