import { NhostClient as C, addSecurityKeyPromise as M, createChangeEmailMachine as N, changeEmailPromise as R, createChangePasswordMachine as K, changePasswordPromise as V, createEnableMfaMachine as D, generateQrCodePromise as F, activateMfaPromise as _, disableMfaPromise as q, createFileUploadMachine as H, uploadFilePromise as Q, createMultipleFilesUploadMachine as $, uploadMultipleFilesPromise as j, encodeQueryParameters as G, rewriteRedirectTo as J, createResetPasswordMachine as Y, resetPasswordPromise as W, createSendVerificationEmailMachine as z, sendVerificationEmailPromise as B, signInAnonymousPromise as X, signInEmailPasswordPromise as Z, signInMfaTotpPromise as b, signInEmailPasswordlessPromise as ee, signInEmailSecurityKeyPromise as te, elevateEmailSecurityKeyPromise as se, signInPATPromise as ne, signInSmsPasswordlessPromise as oe, signInSmsPasswordlessOtpPromise as k, signOutPromise as re, signUpEmailPasswordPromise as ce, signUpEmailSecurityKeyPromise as ie, signInEmailOTPPromise as ae, verifyEmailOTPPromise as ue, signInIdTokenPromise as le, linkIdTokenPromise as de, signInSecurityKeyPromise as he } from "@nhost/nhost-js";
import { NHOST_REFRESH_TOKEN_KEY as ht } from "@nhost/nhost-js";
import me, { createContext as ge, useRef as Ee, useEffect as T, useContext as y, createElement as O, Fragment as w, useState as x, useMemo as P, useCallback as fe } from "react";
import { useInterpret as S, useSelector as n } from "@xstate/react";
import { jwtDecode as pe } from "jwt-decode";
const ve = C;
class we extends ve {
  constructor(t) {
    super({ ...t, start: !1 });
  }
}
const I = ge({}), xe = ({
  nhost: e,
  initial: t,
  ...r
}) => {
  const i = S(e.auth.client.machine, { devTools: e.devTools });
  e.auth.client.start({ interpreter: i, initialSession: t, devTools: e.devTools });
  const d = Ee(!0);
  return T(() => {
    d.current ? d.current = !1 : t && i.send("SESSION_UPDATE", { data: { session: t } });
  }, [t, i]), /* @__PURE__ */ me.createElement(I.Provider, { value: e }, r.children);
}, Ae = xe, p = () => {
  var r;
  const t = (r = y(I).auth) == null ? void 0 : r.client.interpreter;
  if (!t)
    throw Error("Could not find the Nhost auth client. Did you wrap your app in <NhostProvider />?");
  return t;
}, A = () => {
  const e = p();
  return n(
    e,
    (t) => ({
      isAuthenticated: t.matches({ authentication: "signedIn" }),
      isLoading: t.hasTag("loading"),
      error: t.context.errors.authentication || null,
      isError: t.matches({ authentication: { signedOut: "failed" } }),
      connectionAttempts: t.context.importTokenAttempts
    }),
    (t, r) => t.isAuthenticated === r.isAuthenticated && t.isLoading === r.isLoading && t.connectionAttempts === r.connectionAttempts
  );
};
function Ue({ children: e }) {
  const { isAuthenticated: t } = A();
  return t ? O(w, null, e) : null;
}
function Le({ children: e }) {
  const { isAuthenticated: t } = A();
  return t ? null : O(w, null, e);
}
const U = () => {
  const e = p();
  return n(e, (t) => t.context.accessToken.value);
}, v = () => y(I), Ce = () => {
  const e = v(), [t, r] = x(null), i = !t, d = !!t, [l, h] = x(!1);
  return { add: async (a) => {
    h(!0);
    const s = await M(e.auth.client, a), { error: o } = s;
    return o && r(o), h(!1), s;
  }, isLoading: l, isSuccess: i, isError: d, error: t };
}, Me = () => {
  const e = p(), [t, r] = x(
    !!e.status && e.getSnapshot().matches({ authentication: "signedIn" })
  );
  return T(() => e.subscribe((d) => {
    const l = d.matches({ authentication: "signedIn" });
    r(l);
  }).unsubscribe, [e]), t;
};
function Ne(e) {
  const t = v(), r = P(() => N(t.auth.client), [t]), i = S(r), d = n(i, (s) => s.matches("requesting")), l = n(i, (s) => s.context.error), h = n(i, (s) => s.matches("idle.error")), m = n(i, (s) => s.matches("idle.success"));
  return { changeEmail: fe(
    async (s, o = e) => R(i, s, o),
    [i, e]
  ), isLoading: d, needsEmailVerification: m, isError: h, error: l };
}
const Re = () => {
  const e = v(), t = P(() => K(e.auth.client), [e]), r = S(t), i = n(r, (a) => a.matches({ idle: "error" })), d = n(r, (a) => a.matches({ idle: "success" })), l = n(r, (a) => a.context.error), h = n(r, (a) => a.matches("requesting"));
  return { changePassword: (a) => V(r, a), isLoading: h, isSuccess: d, isError: i, error: l };
}, Ke = () => {
  const e = v(), t = P(() => D(e.auth.client), [e]), r = S(t), i = n(
    r,
    (f) => f.matches({ idle: "error" }) || f.matches({ generated: { idle: "error" } })
  ), d = n(r, (f) => f.matches("generating")), l = n(r, (f) => f.matches("generated")), h = n(r, (f) => f.matches({ generated: "activating" })), m = n(r, (f) => f.matches({ generated: "activated" })), a = n(r, (f) => f.matches("disabling")), s = n(r, (f) => f.context.error), o = n(r, (f) => f.context.imageUrl || ""), c = n(r, (f) => f.context.secret || "");
  return {
    generateQrCode: () => F(r),
    isGenerating: d,
    qrCodeDataUrl: o,
    isGenerated: l,
    activateMfa: (f) => _(r, f),
    isActivating: h,
    isActivated: m,
    isDisabling: a,
    isError: i,
    error: s,
    disableMfa: (f) => q(r, f),
    totpSecret: c
  };
}, Se = () => {
  const e = U();
  return e ? pe(e) : null;
}, Pe = (e) => {
  const t = v(), r = (g) => {
    e.send({
      type: "ADD",
      file: g.file,
      bucketId: g.bucketId || E
    });
  }, i = (g) => Q(
    {
      url: t.storage.url,
      accessToken: t.auth.getAccessToken(),
      adminSecret: t.adminSecret,
      ...g
    },
    e
  ), d = () => {
    e.send("CANCEL");
  }, l = () => {
    e.send("DESTROY");
  }, h = n(e, (g) => g.matches("uploading")), m = n(e, (g) => g.matches("uploaded")), a = n(e, (g) => g.matches("error")), s = n(e, (g) => g.context.error || null), o = n(e, (g) => g.context.progress), c = n(e, (g) => g.context.id), E = n(e, (g) => g.context.bucketId), u = n(e, (g) => {
    var f;
    return (f = g.context.file) == null ? void 0 : f.name;
  });
  return {
    add: r,
    upload: i,
    cancel: d,
    destroy: l,
    isUploaded: m,
    isUploading: h,
    isError: a,
    error: s,
    progress: o,
    id: c,
    bucketId: E,
    name: u
  };
}, Ve = () => {
  const e = S(H);
  return Pe(e);
}, L = () => {
  const e = Se();
  return (e == null ? void 0 : e["https://hasura.io/jwt/claims"]) || null;
}, De = (e) => {
  const t = L();
  return (t == null ? void 0 : t[e.startsWith("x-hasura-") ? e : `x-hasura-${e}`]) || null;
}, Fe = () => {
  const e = v(), [t, r] = x([]), i = S($, {}, (u) => {
    u.event.type === "UPLOAD_ERROR" ? r(u.context.files.filter((g) => {
      var f;
      return (f = g.getSnapshot()) == null ? void 0 : f.context.error;
    })) : (u.matches("uploaded") || u.event.type === "CLEAR") && t.length > 0 && r([]);
  }), d = (u) => {
    i.send({ type: "ADD", ...u });
  }, l = (u) => j(
    {
      url: e.storage.url,
      accessToken: e.auth.getAccessToken(),
      adminSecret: e.adminSecret,
      ...u
    },
    i
  ), h = () => {
    i.send("CANCEL");
  }, m = () => {
    i.send("CLEAR");
  }, a = n(i, (u) => u.matches("uploading")), s = n(i, (u) => u.matches("uploaded")), o = n(i, (u) => u.matches("error")), c = n(i, (u) => u.context.progress), E = n(i, (u) => u.context.files);
  return {
    upload: l,
    add: d,
    clear: m,
    cancel: h,
    progress: c,
    isUploaded: s,
    isUploading: a,
    files: E,
    isError: o,
    errors: t
  };
}, _e = (e) => {
  const [t, r] = x(!0), i = U();
  T(() => {
    r(!1);
  }, []);
  const d = y(I);
  return new Proxy({}, {
    get(l, h) {
      let m = `${d.auth.client.backendUrl}/signin/provider/${h}`;
      const a = e != null && e.connect ? { connect: i } : {};
      return G(
        m,
        J(t ? void 0 : d.auth.client.clientUrl, {
          ...e,
          ...a
        })
      );
    }
  });
}, qe = (e) => {
  const t = v(), r = P(() => Y(t.auth.client), [t]), i = S(r), d = n(i, (s) => s.matches("requesting")), l = n(i, (s) => s.context.error), h = n(i, (s) => s.matches("idle.error")), m = n(i, (s) => s.matches("idle.success"));
  return { resetPassword: (s, o = e) => W(i, s, o), isLoading: d, isSent: m, isError: h, error: l };
}, He = (e) => {
  const t = v(), r = P(() => z(t.auth.client), [t]), i = S(r), d = n(i, (s) => s.matches({ idle: "error" })), l = n(i, (s) => s.matches({ idle: "success" })), h = n(i, (s) => s.context.error), m = n(i, (s) => s.matches("requesting"));
  return { sendEmail: (s, o = e) => B(i, s, o), isLoading: m, isSent: l, isError: d, error: h };
}, Qe = () => {
  const e = p(), t = () => X(e), r = n(
    e,
    (a) => a.context.errors.authentication || null,
    (a, s) => (a == null ? void 0 : a.error) === (s == null ? void 0 : s.error)
  ), i = n(
    e,
    (a) => a.matches({ authentication: { authenticating: "anonymous" } })
  ), d = n(
    e,
    (a) => a.matches({
      authentication: "signedIn"
    })
  ), l = n(
    e,
    (a) => a.matches({ authentication: { signedOut: "failed" } })
  ), h = n(
    e,
    (a) => a.context.user,
    (a, s) => (a == null ? void 0 : a.id) === (s == null ? void 0 : s.id)
  );
  return { accessToken: n(e, (a) => a.context.accessToken.value), error: r, isError: l, isLoading: i, isSuccess: d, signInAnonymous: t, user: h };
}, $e = () => {
  const e = p(), t = (u, g) => Z(e, u, g), r = (u) => b(e, u), i = n(
    e,
    (u) => u.context.user,
    (u, g) => (u == null ? void 0 : u.id) === (g == null ? void 0 : g.id)
  ), d = n(e, (u) => u.context.accessToken.value), l = n(e, (u) => u.context.refreshToken.value), h = n(
    e,
    (u) => u.context.errors.authentication || null,
    (u, g) => (u == null ? void 0 : u.error) === (g == null ? void 0 : g.error)
  ), m = n(
    e,
    (u) => u.matches({
      authentication: "signedIn"
    })
  ), a = n(
    e,
    (u) => u.matches({ authentication: { authenticating: "password" } }),
    (u, g) => u === g
  ), s = n(
    e,
    (u) => u.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (u, g) => u === g
  ), o = n(e, (u) => u.context.mfa !== null), c = n(
    e,
    (u) => u.matches({ authentication: { signedOut: "failed" } }),
    (u, g) => u === g
  ), E = n(e, (u) => u.context.mfa);
  return {
    accessToken: d,
    refreshToken: l,
    error: h,
    isError: c,
    isLoading: a,
    isSuccess: m,
    needsEmailVerification: s,
    needsMfaOtp: o,
    mfa: E,
    sendMfaOtp: r,
    signInEmailPassword: t,
    user: i
  };
};
function je(e) {
  const t = p(), r = (m, a = e) => ee(t, m, a), i = n(
    t,
    (m) => m.context.errors.registration || null,
    (m, a) => (m == null ? void 0 : m.error) === (a == null ? void 0 : a.error)
  ), d = n(t, (m) => m.matches("registration.passwordlessEmail")), l = n(
    t,
    (m) => m.matches("registration.incomplete.needsEmailVerification")
  ), h = n(t, (m) => m.matches("registration.incomplete.failed"));
  return { signInEmailPasswordless: r, isLoading: d, isSuccess: l, isError: h, error: i };
}
const Ge = () => {
  const e = p(), t = (o) => te(e, o), r = n(
    e,
    (o) => o.context.user,
    (o, c) => (o == null ? void 0 : o.id) === (c == null ? void 0 : c.id)
  ), i = n(e, (o) => o.context.accessToken.value), d = n(e, (o) => o.context.refreshToken.value), l = n(
    e,
    (o) => o.context.errors.authentication || null,
    (o, c) => (o == null ? void 0 : o.error) === (c == null ? void 0 : c.error)
  ), h = n(
    e,
    (o) => o.matches({
      authentication: "signedIn"
    })
  ), m = n(
    e,
    (o) => o.matches({ authentication: { authenticating: "securityKeyEmail" } }),
    (o, c) => o === c
  ), a = n(
    e,
    (o) => o.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (o, c) => o === c
  ), s = n(
    e,
    (o) => o.matches({ authentication: { signedOut: "failed" } }),
    (o, c) => o === c
  );
  return {
    accessToken: i,
    refreshToken: d,
    error: l,
    isError: s,
    isLoading: m,
    isSuccess: h,
    needsEmailVerification: a,
    signInEmailSecurityKey: t,
    user: r
  };
}, Te = () => {
  const e = p();
  return n(
    e,
    (t) => t.context.user,
    (t, r) => (t && JSON.stringify(t)) === (r && JSON.stringify(r))
  );
}, Je = () => {
  const e = Te(), t = v(), r = L(), i = e ? (r == null ? void 0 : r["x-hasura-auth-elevated"]) === (e == null ? void 0 : e.id) : !1, [d, l] = x(!!i), h = (m) => se(t.auth.client, m);
  return T(() => {
    l(!!i);
  }, [i]), {
    elevated: d,
    elevateEmailSecurityKey: h
  };
}, Ye = () => {
  const e = p(), t = (s) => ne(e, s), r = n(
    e,
    (s) => s.context.user,
    (s, o) => (s == null ? void 0 : s.id) === (o == null ? void 0 : o.id)
  ), i = n(e, (s) => s.context.accessToken.value), d = n(e, (s) => s.context.refreshToken.value), l = n(
    e,
    (s) => s.context.errors.authentication || null,
    (s, o) => (s == null ? void 0 : s.error) === (o == null ? void 0 : o.error)
  ), h = n(e, (s) => s.matches({ authentication: "signedIn" })), m = n(
    e,
    (s) => s.matches({ authentication: { authenticating: "password" } }),
    (s, o) => s === o
  ), a = n(
    e,
    (s) => s.matches({ authentication: { signedOut: "failed" } }),
    (s, o) => s === o
  );
  return {
    accessToken: i,
    refreshToken: d,
    error: l,
    isError: a,
    isLoading: m,
    isSuccess: h,
    signInPAT: t,
    user: r
  };
};
function We(e) {
  const t = p(), [r, i] = x(""), d = (c, E = e) => (i(c), oe(t, c, E)), l = async (...c) => {
    if (c.length === 2) {
      const [u, g] = c;
      return k(t, u, g);
    }
    const [E] = c;
    return k(t, r, E);
  }, h = n(
    t,
    (c) => c.context.errors.registration || null,
    (c, E) => (c == null ? void 0 : c.error) === (E == null ? void 0 : E.error)
  ), m = n(
    t,
    (c) => c.matches("registration.passwordlessSms") || c.matches("registration.passwordlessSmsOtp")
  ), a = n(t, (c) => c.matches("authentication.signedIn")), s = n(
    t,
    (c) => c.matches("registration.incomplete.needsOtp")
  ), o = n(t, (c) => c.matches("registration.incomplete.failed"));
  return { signInSmsPasswordless: d, sendOtp: l, isLoading: m, isSuccess: a, needsOtp: s, isError: o, error: h };
}
const ze = (e = !1) => {
  const t = p(), r = (l) => re(t, typeof l == "boolean" ? l : e), i = n(
    t,
    (l) => l.matches({ authentication: { signedOut: "success" } }),
    (l, h) => l === h
  ), d = n(
    t,
    (l) => l.context.errors.signout || null,
    (l, h) => (l == null ? void 0 : l.error) === (h == null ? void 0 : h.error)
  );
  return { signOut: r, isSuccess: i, error: d };
}, Be = (e) => {
  const t = p(), r = n(t, (c) => !!c.context.errors.registration), i = n(
    t,
    (c) => c.context.errors.registration || null,
    (c, E) => (c == null ? void 0 : c.error) === (E == null ? void 0 : E.error)
  ), d = n(t, (c) => c.matches("registration.emailPassword")), l = n(
    t,
    (c) => c.matches("registration.incomplete.needsEmailVerification")
  ), h = n(
    t,
    (c) => c.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), m = (c, E, u = e, g) => ce(t, c, E, u, g), a = n(
    t,
    (c) => c.context.user,
    (c, E) => (c == null ? void 0 : c.id) === (E == null ? void 0 : E.id)
  ), s = n(t, (c) => c.context.accessToken.value), o = n(t, (c) => c.context.refreshToken.value);
  return {
    accessToken: s,
    refreshToken: o,
    error: i,
    isError: r,
    isLoading: d,
    isSuccess: h,
    needsEmailVerification: l,
    signUpEmailPassword: m,
    user: a
  };
}, Xe = (e) => {
  const t = p(), r = n(t, (c) => !!c.context.errors.registration), i = n(
    t,
    (c) => c.context.errors.registration || null,
    (c, E) => (c == null ? void 0 : c.error) === (E == null ? void 0 : E.error)
  ), d = n(t, (c) => c.matches("registration.securityKey")), l = n(
    t,
    (c) => c.matches("registration.incomplete.needsEmailVerification")
  ), h = n(
    t,
    (c) => c.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), m = (c, E = e, u) => ie(t, c, E, u), a = n(
    t,
    (c) => c.context.user,
    (c, E) => (c == null ? void 0 : c.id) === (E == null ? void 0 : E.id)
  ), s = n(t, (c) => c.context.accessToken.value), o = n(t, (c) => c.context.refreshToken.value);
  return {
    accessToken: s,
    refreshToken: o,
    error: i,
    isError: r,
    isLoading: d,
    isSuccess: h,
    needsEmailVerification: l,
    signUpEmailSecurityKey: m,
    user: a
  };
}, Ze = () => {
  const e = p();
  return n(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.avatarUrl;
    },
    (t, r) => t === r
  );
}, be = () => {
  const e = p();
  return n(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.defaultRole;
    },
    (t, r) => t === r
  );
}, et = () => {
  const e = p();
  return n(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.displayName;
    },
    (t, r) => t === r
  );
}, tt = () => {
  const e = p();
  return n(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.email;
    },
    (t, r) => t === r
  );
}, st = () => {
  const e = p();
  return n(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.id;
    },
    (t, r) => t === r
  );
}, nt = () => {
  const e = p();
  return n(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.isAnonymous;
    },
    (t, r) => t === r
  );
}, ot = () => {
  const e = p();
  return n(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.locale;
    },
    (t, r) => t === r
  );
}, rt = () => {
  const e = p();
  return n(e, (t) => {
    var r;
    return t.matches("authentication.signedIn") ? ((r = t.context.user) == null ? void 0 : r.roles) || [] : [];
  });
};
function ct(e) {
  const t = p(), r = (s, o = e) => ae(t, s, o), i = async (s, o) => ue(t, s, o), d = n(
    t,
    (s) => s.context.errors.registration || null,
    (s, o) => (s == null ? void 0 : s.error) === (o == null ? void 0 : o.error)
  ), l = n(
    t,
    (s) => s.matches("registration.signInEmailOTP") || s.matches("registration.verifyEmailOTP")
  ), h = n(t, (s) => s.matches("authentication.signedIn")), m = n(
    t,
    (s) => s.matches("registration.incomplete.needsOtp")
  ), a = n(t, (s) => s.matches("registration.incomplete.failed"));
  return { signInEmailOTP: r, verifyEmailOTP: i, isLoading: l, isSuccess: h, isError: a, error: d, needsOtp: m };
}
const it = () => {
  const e = p(), t = (s, o, c) => le(e, {
    provider: s,
    idToken: o,
    nonce: c
  }), r = n(
    e,
    (s) => s.context.user,
    (s, o) => (s == null ? void 0 : s.id) === (o == null ? void 0 : o.id)
  ), i = n(e, (s) => s.context.accessToken.value), d = n(e, (s) => s.context.refreshToken.value), l = n(
    e,
    (s) => s.context.errors.authentication || null,
    (s, o) => (s == null ? void 0 : s.error) === (o == null ? void 0 : o.error)
  ), h = n(e, (s) => s.matches({ authentication: "signedIn" })), m = n(
    e,
    (s) => s.matches({ authentication: { authenticating: "idToken" } }),
    (s, o) => s === o
  ), a = n(
    e,
    (s) => s.matches({ authentication: { signedOut: "failed" } }),
    (s, o) => s === o
  );
  return {
    accessToken: i,
    refreshToken: d,
    error: l,
    isError: a,
    isLoading: m,
    isSuccess: h,
    signInIdToken: t,
    user: r
  };
}, at = () => {
  const e = v(), [t, r] = x(null), i = !t, d = !!t, [l, h] = x(!1);
  return { linkIdToken: async ({
    provider: a,
    idToken: s,
    nonce: o
  }) => {
    h(!0);
    const c = await de(e.auth.client, {
      provider: a,
      idToken: s,
      ...o && { nonce: o }
    }), { error: E } = c;
    return E && r(E), h(!1), c;
  }, isLoading: l, isSuccess: i, isError: d, error: t };
}, ut = () => {
  const e = p(), t = () => he(e), r = n(
    e,
    (o) => o.context.user,
    (o, c) => (o == null ? void 0 : o.id) === (c == null ? void 0 : c.id)
  ), i = n(e, (o) => o.context.accessToken.value), d = n(e, (o) => o.context.refreshToken.value), l = n(
    e,
    (o) => o.context.errors.authentication || null,
    (o, c) => (o == null ? void 0 : o.error) === (c == null ? void 0 : c.error)
  ), h = n(
    e,
    (o) => o.matches({
      authentication: "signedIn"
    })
  ), m = n(
    e,
    (o) => o.matches({ authentication: { authenticating: "securityKeyEmail" } }),
    (o, c) => o === c
  ), a = n(
    e,
    (o) => o.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (o, c) => o === c
  ), s = n(
    e,
    (o) => o.matches({ authentication: { signedOut: "failed" } }),
    (o, c) => o === c
  );
  return {
    accessToken: i,
    refreshToken: d,
    error: l,
    isError: s,
    isLoading: m,
    isSuccess: h,
    needsEmailVerification: a,
    signInSecurityKey: t,
    user: r
  };
};
export {
  ht as NHOST_REFRESH_TOKEN_KEY,
  we as NhostClient,
  xe as NhostProvider,
  I as NhostReactContext,
  Ae as NhostReactProvider,
  Ue as SignedIn,
  Le as SignedOut,
  ve as VanillaNhostClient,
  U as useAccessToken,
  Ce as useAddSecurityKey,
  p as useAuthInterpreter,
  Me as useAuthenticated,
  A as useAuthenticationStatus,
  Ne as useChangeEmail,
  Re as useChangePassword,
  Ke as useConfigMfa,
  Se as useDecodedAccessToken,
  Je as useElevateSecurityKeyEmail,
  Ve as useFileUpload,
  Pe as useFileUploadItem,
  De as useHasuraClaim,
  L as useHasuraClaims,
  at as useLinkIdToken,
  Fe as useMultipleFilesUpload,
  v as useNhostClient,
  _e as useProviderLink,
  qe as useResetPassword,
  He as useSendVerificationEmail,
  Qe as useSignInAnonymous,
  ct as useSignInEmailOTP,
  $e as useSignInEmailPassword,
  je as useSignInEmailPasswordless,
  Ge as useSignInEmailSecurityKey,
  it as useSignInIdToken,
  Ye as useSignInPAT,
  ut as useSignInSecurityKey,
  We as useSignInSmsPasswordless,
  ze as useSignOut,
  Be as useSignUpEmailPassword,
  Xe as useSignUpEmailSecurityKeyEmail,
  Ze as useUserAvatarUrl,
  Te as useUserData,
  be as useUserDefaultRole,
  et as useUserDisplayName,
  tt as useUserEmail,
  st as useUserId,
  nt as useUserIsAnonymous,
  ot as useUserLocale,
  rt as useUserRoles
};
//# sourceMappingURL=index.esm.js.map
